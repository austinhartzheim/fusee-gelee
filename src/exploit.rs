use std::path::PathBuf;
use std::time::Duration;

// USB constants
const STANDARD_REQUEST_DEVICE_TO_HOST_TO_ENDPOINT: u8 = 0x82;
const STANDARD_REQUEST_DEVICE_TO_HOST: u8 = 0x80;
const GET_DESCRIPTOR: u8 = 0x6;
const GET_CONFIGURATION: u8 = 0x8;

// Interface requests
const GET_STATUS: u8 = 0x0;

pub struct ExploitDriver<B: ExploitBackend> {
    /// The exploit backend, providing platform-specific interactions.
    backend: B,
}

impl<B: ExploitBackend> ExploitDriver<B> {
    /// Initialize the `ExploitDriver` by finding a USB device with the provided Vendor ID and
    /// Product ID, returning an error if the device cannot be located.
    pub fn discover(vid: u16, pid: u16) -> Result<Self, ()> {
        Ok(Self {
            backend: B::discover(vid, pid)?,
        })
    }

    fn read(&self, buf: &mut [u8]) -> Result<usize, rusb::Error> {
        self.backend.read(buf)
    }

    /// Read the device ID from the processor. This must happen first as part of the protocol.
    fn read_device_id(&self) -> Result<(), rusb::Error> {
        let mut buf = [0u8; 16];
        self.read(&mut buf)?;

        Ok(())
    }
}

/// Abstracts over platform-dependant exploit backends so multiple platforms may be supported.
pub trait ExploitBackend {
    /// Scan USB devices, returning an attached exploit backend for the first device matching the
    /// `vid` and `pid` pair.
    fn discover(vid: u16, pid: u16) -> Result<Self, ()>
    where
        Self: Sized;

    /// Performs a bulk read on the bound USB device.
    fn read(&self, buf: &mut [u8]) -> Result<usize, rusb::Error>;

    /// Performs a bulk write on the bound USB device.
    fn write(&self, buf: &[u8]) -> Result<usize, rusb::Error>;
}

pub struct LinuxBackend {
    device_handle: rusb::DeviceHandle<rusb::GlobalContext>,
    bus: u8,
    port: u8,
}

impl LinuxBackend {
    fn device_path(&self) -> PathBuf {
        PathBuf::from(format!(
            "/dev/bus/usb/{:03}/{:03}",
            self.bus,
            self.port,
        ))
    }
}

impl ExploitBackend for LinuxBackend {
    fn discover(vid: u16, pid: u16) -> Result<Self, ()> {
        rusb::devices()
            .expect("Could not list USB devices")
            .iter()
            .filter(|device| {
                if let Ok(descriptor) = device.device_descriptor() {
                    descriptor.vendor_id() == vid && descriptor.product_id() == pid
                } else {
                    false
                }
            })
            .take(1)
            .next()
            .map(|device| Self {
                device_handle: device.open().expect("Failed to open USB device"),
                bus: device.bus_number(),
                port: device.port_number(),
            })
            .ok_or(())
    }

    fn read(&self, buf: &mut [u8]) -> Result<usize, rusb::Error> {
        self.device_handle
            .read_bulk(0x81, buf, Duration::from_secs(1))
    }

    fn write(&self, buf: &[u8]) -> Result<usize, rusb::Error> {
        self.device_handle
            .write_bulk(0x01, buf, Duration::from_secs(1))
    }
}

/// Build the buffer for the IoctlUrb buffer.
fn build_packet(length: u16) -> [u8; 8] {
    let mut arr = [0u8; 8];
    arr[0] = STANDARD_REQUEST_DEVICE_TO_HOST_TO_ENDPOINT.to_le();
    arr[1] = GET_STATUS.to_le();
    // arr[2..6] remain zero
    let [length_low, length_high] = length.to_le_bytes();
    arr[6] = length_low;
    arr[7] = length_high;

    arr
}