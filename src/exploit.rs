use std::path::PathBuf;

/// Abstracts over platform-dependant exploit backends so multiple platforms may be supported.
pub trait ExploitBackend {
    /// Scan USB devices, returning an attached exploit backend for the first device matching the
    /// `vid` and `pid` pair.
    fn discover(vid: u16, pid: u16) -> Result<Self, ()>
    where
        Self: Sized;
}

pub struct LinuxBackend {
    device_handle: rusb::DeviceHandle<rusb::GlobalContext>,
    bus: u8,
    port: u8,
}

impl LinuxBackend {
    fn device_path(&self) -> PathBuf {
        PathBuf::from(format!(
            "/dev/bus/usb/{:03}/{:03}",
            self.bus,
            self.port,
        ))
    }
}

impl ExploitBackend for LinuxBackend {
    fn discover(vid: u16, pid: u16) -> Result<Self, ()> {
        rusb::devices()
            .expect("Could not list USB devices")
            .iter()
            .filter(|device| {
                if let Ok(descriptor) = device.device_descriptor() {
                    descriptor.vendor_id() == vid && descriptor.product_id() == pid
                } else {
                    false
                }
            })
            .take(1)
            .next()
            .map(|device| Self {
                device_handle: device.open().expect("Failed to open USB device"),
                bus: device.bus_number(),
                port: device.port_number(),
            })
            .ok_or(())
    }
}